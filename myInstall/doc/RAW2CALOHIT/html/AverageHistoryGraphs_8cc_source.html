<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RAW2CALOHIT: AverageHistoryGraphs.cc Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_f98b43a53f5533225f05987ae358305b.html">calice_reco</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_8656c002b32f5afd83fbcb1fc9f618b8.html">raw2calohit</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_4ccc65e3147d3d4ef3c56822860bbd3e.html">src</a>
  </div>
</div>
<div class="contents">
<h1>AverageHistoryGraphs.cc</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#  include &lt;config.h&gt;</span> 
<a name="l00003"></a>00003 <span class="preprocessor">#endif </span>
<a name="l00004"></a>00004 <span class="preprocessor"></span>
<a name="l00005"></a>00005 <span class="comment">//#ifdef HAVE_ROOT</span>
<a name="l00006"></a>00006 <span class="comment">//#include &lt;TFile.h&gt;</span>
<a name="l00007"></a>00007 <span class="comment">//#include &lt;TGraph.h&gt;</span>
<a name="l00008"></a>00008 <span class="comment">//#include &lt;TGraphErrors.h&gt;</span>
<a name="l00009"></a>00009 <span class="comment">//#endif</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;AverageHistoryGraphs.hh&quot;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;AdcValueAccess.hh&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;Average_t.hh&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;CellParameter.hh&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;EVENT/LCParameters.h&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;marlin/ConditionsProcessor.h&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;collection_names.hh&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;MakeGraph.hh&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;histmgr/GraphCollection_t.hh&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;histmgr/HistMgr.hh&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;ErrorBits.hh&gt;</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="comment">//#include &lt;sstream&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#define PAR_EVENTS_SINCE_LAST_DAQ_STATE_CHANGE &quot;CALDAQ_EventsSinceLastChange&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span>
<a name="l00028"></a>00028 <span class="keyword">namespace </span>CALICE {
<a name="l00029"></a>00029   AverageHistoryGraphs a_AverageHistoryGraphs_instance;
<a name="l00030"></a>00030 
<a name="l00031"></a>00031   <span class="keyword">const</span> <span class="keywordtype">char</span> *AverageHistoryGraphs::__historyGraphNames[AverageHistoryGraphs::kNHistoryGraphs] ={
<a name="l00032"></a>00032     <span class="stringliteral">&quot;ADCHistory&quot;</span>,
<a name="l00033"></a>00033     <span class="stringliteral">&quot;NoiseHistory&quot;</span>,
<a name="l00034"></a>00034     <span class="stringliteral">&quot;PedestalHistory&quot;</span>,
<a name="l00035"></a>00035     <span class="stringliteral">&quot;HitHistory&quot;</span>
<a name="l00036"></a>00036   };
<a name="l00037"></a>00037 
<a name="l00038"></a>00038   <span class="keyword">const</span> <span class="keywordtype">char</span> *AverageHistoryGraphs::__graphTypeNames[AverageHistoryGraphs::kNGraphTypes] ={
<a name="l00039"></a>00039     <span class="stringliteral">&quot;mean&quot;</span>,
<a name="l00040"></a>00040     <span class="stringliteral">&quot;rms&quot;</span>,
<a name="l00041"></a>00041     <span class="stringliteral">&quot;min&quot;</span>,
<a name="l00042"></a>00042     <span class="stringliteral">&quot;max&quot;</span>,
<a name="l00043"></a>00043     <span class="stringliteral">&quot;weight&quot;</span>
<a name="l00044"></a>00044   };
<a name="l00045"></a>00045 
<a name="l00046"></a>00046   UInt_t AverageHistoryGraphs::__nSamplesPerChip=18;
<a name="l00047"></a>00047   UInt_t AverageHistoryGraphs::__nChips=12;
<a name="l00048"></a>00048 
<a name="l00049"></a>00049   AverageHistoryGraphs::AverageHistoryGraphs()
<a name="l00050"></a>00050     :    VRawADCValueProcessor(<span class="stringliteral">&quot;AverageHistoryGraphs&quot;</span>),
<a name="l00051"></a>00051          _stateChangeHistoryKey(<span class="stringliteral">&quot;StateChangeHistory&quot;</span>),
<a name="l00052"></a>00052          _confChangeHistoryKey(<span class="stringliteral">&quot;ConfigurationChangeHistory&quot;</span>)
<a name="l00053"></a>00053   {
<a name="l00054"></a>00054 
<a name="l00055"></a>00055     <span class="comment">//_outputFileName=&quot;history.root&quot;;</span>
<a name="l00056"></a>00056     <span class="comment">//    registerProcessorParameter( &quot;ResultsFile&quot; , </span>
<a name="l00057"></a>00057     <span class="comment">//                         &quot;The history graphs will be written to the ROOT file of this name.&quot; ,</span>
<a name="l00058"></a>00058     <span class="comment">//                         _outputFileName ,</span>
<a name="l00059"></a>00059     <span class="comment">//                         _outputFileName);</span>
<a name="l00060"></a>00060 
<a name="l00061"></a>00061     <span class="comment">//    _folderName=&quot;&quot;;</span>
<a name="l00062"></a>00062     <span class="comment">//    registerProcessorParameter( &quot;HistogramDirectoryName&quot; , </span>
<a name="l00063"></a>00063     <span class="comment">//                         &quot;The name of the directory inside the ROOT file to which the history graphs are written to.&quot; ,</span>
<a name="l00064"></a>00064     <span class="comment">//                         _folderName ,</span>
<a name="l00065"></a>00065     <span class="comment">//                         _folderName);</span>
<a name="l00066"></a>00066 
<a name="l00067"></a>00067     _useTimeStamp=0;
<a name="l00068"></a>00068     registerProcessorParameter( <span class="stringliteral">&quot;UseTime&quot;</span> , 
<a name="l00069"></a>00069                                <span class="stringliteral">&quot;Use the time stamps instead of the event number.&quot;</span> ,
<a name="l00070"></a>00070                                _useTimeStamp,
<a name="l00071"></a>00071                                _useTimeStamp);
<a name="l00072"></a>00072 
<a name="l00073"></a>00073     _cellParameterCollectionName=<span class="stringliteral">&quot;CellParameters&quot;</span>;
<a name="l00074"></a>00074     registerProcessorParameter( <span class="stringliteral">&quot;CellParameterCollectionName&quot;</span> , 
<a name="l00075"></a>00075                                 <span class="stringliteral">&quot;The name of the collection which contains the pedestals, the noise, etc. of all the cells.&quot;</span> ,
<a name="l00076"></a>00076                                 _cellParameterCollectionName ,
<a name="l00077"></a>00077                                 _cellParameterCollectionName);
<a name="l00078"></a>00078 
<a name="l00079"></a>00079     _monitorConf.clear();
<a name="l00080"></a>00080     registerProcessorParameter( <span class="stringliteral">&quot;MonitorConditionsChanges&quot;</span> , 
<a name="l00081"></a>00081                                <span class="stringliteral">&quot;Memorise the event numbers after configuration changes.&quot;</span> ,
<a name="l00082"></a>00082                                _monitorConf,
<a name="l00083"></a>00083                                _monitorConf);
<a name="l00084"></a>00084 
<a name="l00085"></a>00085     _signalCut=5.;
<a name="l00086"></a>00086     registerProcessorParameter( <span class="stringliteral">&quot;SignalCut&quot;</span> , 
<a name="l00087"></a>00087                                 <span class="stringliteral">&quot;ADC values of cells with a signal-over-noise larger than this value will not be considered.&quot;</span> ,
<a name="l00088"></a>00088                                 _signalCut ,
<a name="l00089"></a>00089                                 _signalCut);
<a name="l00090"></a>00090 
<a name="l00091"></a>00091     registerProcessorParameter( <span class="stringliteral">&quot;SkipCalibrationEvents&quot;</span> , 
<a name="l00092"></a>00092                                <span class="stringliteral">&quot;Skip events for which the calibration chip was switched on (Otherwise they are treated as beam events)&quot;</span> ,
<a name="l00093"></a>00093                                _skipCalibrationEventsAlways ,
<a name="l00094"></a>00094                                0) ;
<a name="l00095"></a>00095 
<a name="l00096"></a>00096     _eventPar.clear();
<a name="l00097"></a>00097     _eventPar.push_back(100);
<a name="l00098"></a>00098     _eventPar.push_back(0);
<a name="l00099"></a>00099     _eventPar.push_back(200000);
<a name="l00100"></a>00100     registerOptionalParameter( <span class="stringliteral">&quot;EventStepsAndRange&quot;</span> , 
<a name="l00101"></a>00101                                 <span class="stringliteral">&quot;Event step size, first event, and last event. The history is extended in events steps given by the first parameter for events in the range indicated by the second and third parameter&quot;</span>  ,
<a name="l00102"></a>00102                                 _eventPar ,
<a name="l00103"></a>00103                                _eventPar);
<a name="l00104"></a>00104 
<a name="l00105"></a>00105     _avADCNMax=10;
<a name="l00106"></a>00106     registerProcessorParameter( <span class="stringliteral">&quot;AverageOverNEvents&quot;</span> , 
<a name="l00107"></a>00107                                <span class="stringliteral">&quot;Calculate per average ADC values per pad using this number of ADC values.&quot;</span> ,
<a name="l00108"></a>00108                                _avADCNMax,
<a name="l00109"></a>00109                                _avADCNMax);
<a name="l00110"></a>00110 
<a name="l00111"></a>00111     registerProcessorParameter( <span class="stringliteral">&quot;HistogramGroupName&quot;</span> , 
<a name="l00112"></a>00112                                 <span class="stringliteral">&quot;The name of the histogram group under which the control histograms will be registered.&quot;</span>  ,
<a name="l00113"></a>00113                                 _graphGroupKey.nameStorage() ,
<a name="l00114"></a>00114                                 type() );
<a name="l00115"></a>00115     
<a name="l00116"></a>00116     <span class="keywordflow">for</span> (UInt_t history_i=0; history_i&lt;kNHistoryGraphs; history_i++) {
<a name="l00117"></a>00117       _avValueHistoryKey.push_back(<a class="code" href="classhistmgr_1_1Key__t.html" title="A string key which will get a numeric identifier.">histmgr::Key_t</a>(__historyGraphNames[history_i]));
<a name="l00118"></a>00118     }
<a name="l00119"></a>00119   }
<a name="l00120"></a>00120 
<a name="l00121"></a><a class="code" href="classCALICE_1_1AverageHistoryGraphs.html#a3734a824ecbe14585605e459c40b7f67">00121</a>   <span class="keywordtype">void</span> <a class="code" href="classCALICE_1_1AverageHistoryGraphs.html#a3734a824ecbe14585605e459c40b7f67" title="Called at the begin of the job before anything is read.">AverageHistoryGraphs::init</a>() {
<a name="l00122"></a>00122     <a class="code" href="classCALICE_1_1AverageHistoryGraphs.html#a3734a824ecbe14585605e459c40b7f67" title="Called at the begin of the job before anything is read.">VRawADCValueProcessor::init</a>();
<a name="l00123"></a>00123     printParameters();
<a name="l00124"></a>00124 
<a name="l00125"></a>00125     assert(_eventPar.size()==3);
<a name="l00126"></a>00126     assert(_eventPar[0]&gt;0);
<a name="l00127"></a>00127     assert(_eventPar[1]&lt;=_eventPar[2]);
<a name="l00128"></a>00128 
<a name="l00129"></a>00129     _nStateChanges=0;
<a name="l00130"></a>00130     _wasState=0;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132     _confChanged=<span class="keyword">false</span>;
<a name="l00133"></a>00133     std::cout &lt;&lt; <span class="stringliteral">&quot;Monitor changes of  &quot;</span>;
<a name="l00134"></a>00134     <span class="keywordflow">for</span> (StringVec::const_iterator name_iter=_monitorConf.begin();
<a name="l00135"></a>00135          name_iter!=_monitorConf.end();
<a name="l00136"></a>00136          name_iter++) {
<a name="l00137"></a>00137       ConditionsChangeDelegator&lt;AverageHistoryGraphs&gt; a(<span class="keyword">this</span>,&amp;AverageHistoryGraphs::configurationChanged);
<a name="l00138"></a>00138       _confChanges.push_back( a );
<a name="l00139"></a>00139     }
<a name="l00140"></a>00140 
<a name="l00141"></a>00141     UInt_t i=0;
<a name="l00142"></a>00142     <span class="keywordflow">for</span> (StringVec::const_iterator name_iter=_monitorConf.begin();
<a name="l00143"></a>00143          name_iter!=_monitorConf.end();
<a name="l00144"></a>00144          name_iter++, i++) {
<a name="l00145"></a>00145       
<a name="l00146"></a>00146       marlin::ConditionsProcessor::registerChangeListener( &amp;(_confChanges[i]) ,
<a name="l00147"></a>00147                                                            *name_iter );
<a name="l00148"></a>00148       std::cout  &lt;&lt; *name_iter &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     }
<a name="l00151"></a>00151     std::cout &lt;&lt; endl;
<a name="l00152"></a>00152     _avADCIsValid=<span class="keyword">false</span>;
<a name="l00153"></a>00153     _avADCn=0;
<a name="l00154"></a>00154 
<a name="l00155"></a>00155     EVENT::StringVec empty;
<a name="l00156"></a>00156     <a class="code" href="classhistmgr_1_1HistMgr.html" title="Manages lists of histograms which can be written to prior assigned files.">histmgr::HistMgr</a> *histogramList=histmgr::HistMgr::getInstance();
<a name="l00157"></a>00157     histogramList-&gt;<a class="code" href="classhistmgr_1_1HistMgr.html#a04aa842cbcd765c10fa47afd05a31b6f" title="Create an empty histogram group to which histograms can be assigned.">createHistogramGroup</a>(_graphGroupKey);
<a name="l00158"></a>00158     histogramList-&gt;<a class="code" href="classhistmgr_1_1HistMgr.html#abe2360d4b53c1ac18f193be4e9428e3a" title="Lock a histogram group.">lockGroup</a>(_graphGroupKey);
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     histogramList-&gt;<a class="code" href="classhistmgr_1_1HistMgr.html#a9db9fef02a9f5b9d113278cfb9615202" title="Create a collection of graphs.">createGraphCollection</a>(_graphGroupKey,_stateChangeHistoryKey,1,empty,0,empty,<span class="keyword">false</span>);
<a name="l00161"></a>00161     histogramList-&gt;<a class="code" href="classhistmgr_1_1HistMgr.html#a9db9fef02a9f5b9d113278cfb9615202" title="Create a collection of graphs.">createGraphCollection</a>(_graphGroupKey,_confChangeHistoryKey,1,empty,0,empty,<span class="keyword">false</span>);
<a name="l00162"></a>00162 
<a name="l00163"></a>00163   }
<a name="l00164"></a>00164 
<a name="l00165"></a>00165   <span class="keywordtype">void</span> AverageHistoryGraphs::resizeArrays() {
<a name="l00166"></a>00166     <span class="keywordflow">if</span> (!_mapping.isModuleConditionsDataComplete()) <span class="keywordflow">return</span>;
<a name="l00167"></a>00167     <span class="keywordflow">if</span> (_mapping.getNModules()==0) <span class="keywordflow">return</span>;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169     <a class="code" href="classhistmgr_1_1HistMgr.html" title="Manages lists of histograms which can be written to prior assigned files.">histmgr::HistMgr</a> *histogramList=histmgr::HistMgr::getInstance();
<a name="l00170"></a>00170 
<a name="l00171"></a>00171     Bool_t need_to_resize_array=<span class="keyword">false</span>;
<a name="l00172"></a>00172     assert (_avValueHistoryKey.size()&gt;0 );
<a name="l00173"></a>00173     <span class="keywordflow">if</span> (_mapping.getNModules()!=_avADC.size() 
<a name="l00174"></a>00174         || !histogramList-&gt;histogramGroupExists(_graphGroupKey) 
<a name="l00175"></a>00175         || !histogramList-&gt;histogramGroup(_graphGroupKey).histogramCollectionExists(_avValueHistoryKey[0])
<a name="l00176"></a>00176         || !histogramList-&gt;histogramGroup(_graphGroupKey).histogramCollection(_avValueHistoryKey[0]).nMajor()==_mapping.getNModules()) {
<a name="l00177"></a>00177       need_to_resize_array=<span class="keyword">true</span>;
<a name="l00178"></a>00178     }
<a name="l00179"></a>00179     <span class="keywordflow">else</span> {
<a name="l00180"></a>00180       <span class="keywordflow">for</span> (UInt_t module_i=0; module_i&lt;_mapping.getNModules(); module_i++) {
<a name="l00181"></a>00181         <span class="keywordflow">if</span> (   _mapping.getNCellsPerModule(module_i) != _avADC[module_i].size()
<a name="l00182"></a>00182             || _mapping.getNCellsPerModule(module_i)/__nSamplesPerChip != histogramList-&gt;histogramGroup(_graphGroupKey).histogramCollection(_avValueHistoryKey[0]).nMinor(module_i)) {
<a name="l00183"></a>00183           need_to_resize_array=<span class="keyword">true</span>;
<a name="l00184"></a>00184         }
<a name="l00185"></a>00185       }
<a name="l00186"></a>00186     }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188     <span class="keywordflow">if</span> (!need_to_resize_array) <span class="keywordflow">return</span>;
<a name="l00189"></a>00189 
<a name="l00190"></a>00190     histogramList-&gt;<a class="code" href="classhistmgr_1_1HistMgr.html#ac3793935c147dc10f3ef167632794802" title="write all histograms groups to the assigned files.">writeHistograms</a>(_graphGroupKey, <span class="keyword">true</span>);
<a name="l00191"></a>00191     <span class="comment">// writeGraphs();</span>
<a name="l00192"></a>00192 
<a name="l00193"></a>00193     _avADC.clear();
<a name="l00194"></a>00194     _avADC.resize(_mapping.getNModules());
<a name="l00195"></a>00195     <span class="keywordflow">for</span> (UInt_t module_i=0; module_i&lt;_mapping.getNModules(); module_i++) {
<a name="l00196"></a>00196       _avADC[module_i].resize(_mapping.getNCellsPerModule(module_i));
<a name="l00197"></a>00197     }
<a name="l00198"></a>00198     _avADCIsValid=<span class="keyword">false</span>;
<a name="l00199"></a>00199     _avADCn=0;
<a name="l00200"></a>00200     <span class="keywordflow">for</span> (UInt_t history_i=0; history_i&lt;kNHistoryGraphs; history_i++) {
<a name="l00201"></a>00201       _avValues[history_i].clear();
<a name="l00202"></a>00202       _avValues[history_i].resize(_mapping.getNModules());
<a name="l00203"></a>00203       <span class="keywordflow">for</span> (UInt_t module_i=0; module_i&lt;_mapping.getNModules(); module_i++) {
<a name="l00204"></a>00204         _avValues[history_i][module_i].resize(_mapping.getNCellsPerModule(module_i)/__nSamplesPerChip);
<a name="l00205"></a>00205       }
<a name="l00206"></a>00206     }
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 
<a name="l00209"></a>00209     EVENT::StringVec types;
<a name="l00210"></a>00210     <span class="keywordflow">for</span> (UInt_t type_i=0; type_i&lt;kNGraphTypes; type_i++) {
<a name="l00211"></a>00211       types.push_back(__graphTypeNames[type_i]);
<a name="l00212"></a>00212     }
<a name="l00213"></a>00213     
<a name="l00214"></a>00214     EVENT::IntVec n_chips;
<a name="l00215"></a>00215     <span class="keywordflow">for</span> (UInt_t module_i=0; module_i&lt;_mapping.getNModules(); module_i++) {
<a name="l00216"></a>00216       n_chips.push_back(_mapping.getNCellsPerModule(module_i)/__nSamplesPerChip);
<a name="l00217"></a>00217     }
<a name="l00218"></a>00218     EVENT::StringVec empty;
<a name="l00219"></a>00219  
<a name="l00220"></a>00220     <span class="keywordflow">for</span> (std::vector&lt;histmgr::Key_t&gt;::const_iterator history_iter=_avValueHistoryKey.begin();
<a name="l00221"></a>00221          history_iter!=_avValueHistoryKey.end();
<a name="l00222"></a>00222          history_iter++) {
<a name="l00223"></a>00223 
<a name="l00224"></a>00224       EVENT::StringVec module_names;
<a name="l00225"></a>00225       <span class="keywordflow">for</span> (UInt_t module_i=0; module_i&lt;_mapping.getNModules(); module_i++) {
<a name="l00226"></a>00226         std::stringstream a_name;
<a name="l00227"></a>00227         CellIndex cell_index(_mapping.getGeometricalCellIndex(module_i,0));
<a name="l00228"></a>00228         a_name &lt;&lt; history_iter-&gt;name() &lt;&lt; <span class="stringliteral">&quot;_module_&quot;</span> &lt;&lt; module_i &lt;&lt; <span class="stringliteral">&quot;_&quot;</span> &lt;&lt; _mapping.getModuleName(module_i) &lt;&lt; <span class="stringliteral">&quot;_layer_&quot;</span> &lt;&lt; cell_index.getLayerIndex();
<a name="l00229"></a>00229         module_names.push_back(a_name.str());
<a name="l00230"></a>00230       }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232       histogramList-&gt;<a class="code" href="classhistmgr_1_1HistMgr.html#a9db9fef02a9f5b9d113278cfb9615202" title="Create a collection of graphs.">createGraphCollection</a>(_graphGroupKey,*history_iter,n_chips,types,0,module_names,<span class="keyword">true</span>);
<a name="l00233"></a>00233     }
<a name="l00234"></a>00234     
<a name="l00235"></a>00235     <span class="comment">//    for (UInt_t history_i=0; history_i&lt;kNHistoryGraphs; history_i++) {</span>
<a name="l00236"></a>00236     <span class="comment">//      for (UInt_t graph_i=0; graph_i&lt;kNGraphs; graph_i++) {</span>
<a name="l00237"></a>00237     <span class="comment">//  _history[history_i][graph_i].clear();</span>
<a name="l00238"></a>00238     <span class="comment">//  _history[history_i][graph_i].resize(_mapping.getNModules());</span>
<a name="l00239"></a>00239     <span class="comment">//  for (UInt_t module_i=0; module_i&lt;_mapping.getNModules(); module_i++) {</span>
<a name="l00240"></a>00240     <span class="comment">//    _history[history_i][graph_i][module_i].resize(_mapping.getNCellsPerModule(module_i)/__nSamplesPerChip);</span>
<a name="l00241"></a>00241     <span class="comment">//  }</span>
<a name="l00242"></a>00242     <span class="comment">//      }</span>
<a name="l00243"></a>00243     <span class="comment">//    }</span>
<a name="l00244"></a>00244     <span class="comment">//</span>
<a name="l00245"></a>00245     <span class="comment">//    for (UInt_t hist_i=0; hist_i&lt;kNHistoryStamps; hist_i++) {</span>
<a name="l00246"></a>00246     <span class="comment">//      _historyStamps[hist_i].clear();</span>
<a name="l00247"></a>00247     <span class="comment">//    }</span>
<a name="l00248"></a>00248 
<a name="l00249"></a>00249   }
<a name="l00250"></a>00250 
<a name="l00251"></a><a class="code" href="classCALICE_1_1AverageHistoryGraphs.html#a1b70e2c0f46158aac6fe28edb2ca23cf">00251</a>   <span class="keywordtype">void</span> <a class="code" href="classCALICE_1_1AverageHistoryGraphs.html#a1b70e2c0f46158aac6fe28edb2ca23cf" title="Called for every event - the working horse.">AverageHistoryGraphs::processEvent</a>( LCEvent * evtP ) {
<a name="l00252"></a>00252 
<a name="l00253"></a>00253     CALICE::ErrorBits error(evtP-&gt;getParameters().getIntVal(PAR_ERROR_BITS));
<a name="l00254"></a>00254         
<a name="l00255"></a>00255     UInt_t event_nr=evtP-&gt;getEventNumber();
<a name="l00256"></a>00256     Int_t isState=evtP-&gt;parameters().getIntVal(PAR_RECO_STATE);
<a name="l00257"></a>00257 
<a name="l00258"></a>00258     UInt_t events_since_last_slow_conf_record=evtP-&gt;parameters().getIntVal(PAR_EVENTS_SINCE_LAST_DAQ_STATE_CHANGE);
<a name="l00259"></a>00259     
<a name="l00260"></a>00260     <span class="comment">//FIXME: does not make any sense if runs are chained.</span>
<a name="l00261"></a>00261     <span class="keywordflow">if</span> (event_nr&gt;=static_cast&lt;UInt_t&gt;(_eventPar[1]) &amp;&amp; event_nr&lt;=static_cast&lt;UInt_t&gt;(_eventPar[2])) {
<a name="l00262"></a>00262       
<a name="l00263"></a>00263       <a class="code" href="classhistmgr_1_1HistMgr.html" title="Manages lists of histograms which can be written to prior assigned files.">histmgr::HistMgr</a> *histogramList=histmgr::HistMgr::getInstance();
<a name="l00264"></a>00264       <span class="comment">// FIXME: cannot store nanosecond resolution !</span>
<a name="l00265"></a>00265       Float_t stamp=(_useTimeStamp&gt;0 ? <span class="keyword">static_cast&lt;</span>Float_t<span class="keyword">&gt;</span>(evtP-&gt;getTimeStamp()) : static_cast&lt;Float_t&gt;(event_nr));
<a name="l00266"></a>00266       
<a name="l00267"></a>00267       <span class="keywordflow">if</span> (error.corruptEventRecord() || (_skipCalibrationEventsAlways!=0 &amp;&amp; isState==kRecoStateCalibration)) {
<a name="l00268"></a>00268         isState=(error.corruptEventRecord() ? -2 : -1 );
<a name="l00269"></a>00269         <span class="keywordflow">if</span> (_wasState != isState ) {
<a name="l00270"></a>00270           <a class="code" href="classhistmgr_1_1GraphCollection__t.html" title="Light wrapper around a LCCollection to facilitate the handling of collections of...">histmgr::GraphCollection_t</a> &amp;graph_col=histogramList-&gt;<a class="code" href="classhistmgr_1_1HistMgr.html#a6c5ea89b82f7d9df93423976abdf6470" title="Get a graph collection.">getGraphCollection</a>(_graphGroupKey,_stateChangeHistoryKey);
<a name="l00271"></a>00271           UInt_t val_i = graph_col.<a class="code" href="classhistmgr_1_1GraphCollection__t.html#ae9c83cf79211ef808f75343c7c3c3c3d" title="Set the common x value of all the graphs of the graph collection.">appendXValue</a>(stamp);
<a name="l00272"></a>00272           graph_col.<a class="code" href="classhistmgr_1_1GraphCollection__t.html#a2d86a21418a91537e8cb831673b4e88b" title="Set the y-value of the adddressed graph.">setYValue</a>(0,0,val_i, static_cast&lt;float&gt;(isState));
<a name="l00273"></a>00273           _nStateChanges++;
<a name="l00274"></a>00274           <span class="comment">//      _historyStamps[kHistoryStateStamp].push_back(stamp);</span>
<a name="l00275"></a>00275           <span class="comment">//      _historyStamps[kHistoryStateValue].push_back( isState );</span>
<a name="l00276"></a>00276         }
<a name="l00277"></a>00277         _wasState=isState;
<a name="l00278"></a>00278    
<a name="l00279"></a>00279         <span class="keywordflow">return</span>;
<a name="l00280"></a>00280       }
<a name="l00281"></a>00281       
<a name="l00282"></a>00282       <span class="keywordflow">if</span> (_wasState==isState &amp;&amp; events_since_last_slow_conf_record==0) {
<a name="l00283"></a>00283         isState=-5;
<a name="l00284"></a>00284       }
<a name="l00285"></a>00285 
<a name="l00286"></a>00286       <span class="keywordflow">if</span> (_wasState != isState ) {
<a name="l00287"></a>00287         _nStateChanges++;
<a name="l00288"></a>00288         <a class="code" href="classhistmgr_1_1GraphCollection__t.html" title="Light wrapper around a LCCollection to facilitate the handling of collections of...">histmgr::GraphCollection_t</a> &amp;graph_col=histogramList-&gt;<a class="code" href="classhistmgr_1_1HistMgr.html#a6c5ea89b82f7d9df93423976abdf6470" title="Get a graph collection.">getGraphCollection</a>(_graphGroupKey,_stateChangeHistoryKey);
<a name="l00289"></a>00289         UInt_t val_i = graph_col.<a class="code" href="classhistmgr_1_1GraphCollection__t.html#ae9c83cf79211ef808f75343c7c3c3c3d" title="Set the common x value of all the graphs of the graph collection.">appendXValue</a>(stamp);
<a name="l00290"></a>00290         graph_col.<a class="code" href="classhistmgr_1_1GraphCollection__t.html#a2d86a21418a91537e8cb831673b4e88b" title="Set the y-value of the adddressed graph.">setYValue</a>(0,0,val_i, static_cast&lt;float&gt;(isState));
<a name="l00291"></a>00291 
<a name="l00292"></a>00292         <span class="comment">//_historyStamps[kHistoryStateStamp].push_back(stamp);</span>
<a name="l00293"></a>00293         <span class="comment">//_historyStamps[kHistoryStateValue].push_back(isState);</span>
<a name="l00294"></a>00294         _wasState=isState;
<a name="l00295"></a>00295       }
<a name="l00296"></a>00296       <span class="keywordflow">if</span> (_confChanged) {
<a name="l00297"></a>00297         <a class="code" href="classhistmgr_1_1GraphCollection__t.html" title="Light wrapper around a LCCollection to facilitate the handling of collections of...">histmgr::GraphCollection_t</a> &amp;graph_col=histogramList-&gt;<a class="code" href="classhistmgr_1_1HistMgr.html#a6c5ea89b82f7d9df93423976abdf6470" title="Get a graph collection.">getGraphCollection</a>(_graphGroupKey,_confChangeHistoryKey);
<a name="l00298"></a>00298         UInt_t val_i = graph_col.<a class="code" href="classhistmgr_1_1GraphCollection__t.html#ae9c83cf79211ef808f75343c7c3c3c3d" title="Set the common x value of all the graphs of the graph collection.">appendXValue</a>(stamp);
<a name="l00299"></a>00299         graph_col.<a class="code" href="classhistmgr_1_1GraphCollection__t.html#a2d86a21418a91537e8cb831673b4e88b" title="Set the y-value of the adddressed graph.">setYValue</a>(0,0,val_i, 0.);
<a name="l00300"></a>00300         <span class="comment">//      _historyStamps[kHistoryConfStamp].push_back(stamp);</span>
<a name="l00301"></a>00301       }
<a name="l00302"></a>00302       
<a name="l00303"></a>00303       LCCollection* cell_parameters=0;
<a name="l00304"></a>00304       IntVec module_index_array;
<a name="l00305"></a>00305       <span class="keywordflow">try</span> {
<a name="l00306"></a>00306         cell_parameters = evtP-&gt;getCollection( _cellParameterCollectionName ) ;
<a name="l00307"></a>00307         cell_parameters-&gt;getParameters().getIntVals(std::string(<span class="stringliteral">&quot;ModuleStartIndex&quot;</span>),module_index_array);
<a name="l00308"></a>00308         
<a name="l00309"></a>00309       }
<a name="l00310"></a>00310       <span class="keywordflow">catch</span> (  DataNotAvailableException &amp;err) {
<a name="l00311"></a>00311       }
<a name="l00312"></a>00312       
<a name="l00313"></a>00313       
<a name="l00314"></a>00314       <span class="keywordflow">try</span> {
<a name="l00315"></a>00315         LCCollection* col_adc = evtP-&gt;getCollection( <a class="code" href="classCALICE_1_1VRawADCValueProcessor.html#a9af055c07a4e40284ba7851ee901d7af" title="Name of the input collection (INPUT).">_adcColName</a> ) ;
<a name="l00316"></a>00316         <span class="comment">//TODO: not very efficient to copy the int vector every time. In particular, since it rarly changes.</span>
<a name="l00317"></a>00317         <span class="keywordflow">if</span> (col_adc &amp;&amp; col_adc-&gt;getNumberOfElements()&gt;0) {
<a name="l00318"></a>00318             
<a name="l00319"></a>00319             <a class="code" href="classCALICE_1_1AdcValueAccess.html" title="Hide hit reconstruction: ADC value to position mapping, calibration.">AdcValueAccess</a> adc_access(col_adc, &amp;_mapping, 0, 0);
<a name="l00320"></a>00320             <span class="keywordflow">if</span> (adc_access.hasConnectedBlocks()) {
<a name="l00321"></a>00321               <span class="keywordflow">if</span> (!_avADCIsValid) {
<a name="l00322"></a>00322                 <span class="keywordflow">do</span> {
<a name="l00323"></a>00323 <span class="preprocessor">#ifdef BOUNDARY_CHECK</span>
<a name="l00324"></a>00324 <span class="preprocessor"></span>                  assert(       adc_access.getModuleIndex()&lt; _avADC.size());
<a name="l00325"></a>00325 <span class="preprocessor">#endif           </span>
<a name="l00326"></a>00326 <span class="preprocessor"></span>                  
<a name="l00327"></a>00327                   <span class="keywordflow">do</span> {
<a name="l00328"></a>00328                     UInt_t cell_i=adc_access.getCellIndexOnModule();
<a name="l00329"></a>00329 <span class="preprocessor">#ifdef BOUNDARY_CHECK</span>
<a name="l00330"></a>00330 <span class="preprocessor"></span>                    assert(cell_i &lt; _avADC[adc_access.getModuleIndex()].size());
<a name="l00331"></a>00331 <span class="preprocessor">#endif              </span>
<a name="l00332"></a>00332 <span class="preprocessor"></span>                    Int_t raw_adc_value=adc_access.getAdcValue();
<a name="l00333"></a>00333                     
<a name="l00334"></a>00334                     _avADC[adc_access.getModuleIndex()][cell_i].add(raw_adc_value);
<a name="l00335"></a>00335                   } <span class="keywordflow">while</span> (adc_access.nextValue());
<a name="l00336"></a>00336                 } <span class="keywordflow">while</span> (adc_access.nextBlock());
<a name="l00337"></a>00337 
<a name="l00338"></a>00338                 <span class="keywordflow">if</span> (_avADCn++&gt;static_cast&lt;UInt_t&gt;(_avADCNMax)) {
<a name="l00339"></a>00339                   <span class="keywordflow">for</span> (std::vector&lt; std::vector&lt;Average_t&gt; &gt;::iterator module_iter=_avADC.begin();
<a name="l00340"></a>00340                        module_iter!=_avADC.end();
<a name="l00341"></a>00341                        module_iter++) {
<a name="l00342"></a>00342                     <span class="keywordflow">for</span> (std::vector&lt;Average_t&gt;::iterator cell_iter=module_iter-&gt;begin();
<a name="l00343"></a>00343                          cell_iter!=module_iter-&gt;end();
<a name="l00344"></a>00344                          cell_iter++) {
<a name="l00345"></a>00345                       cell_iter-&gt;calculate();
<a name="l00346"></a>00346                     }
<a name="l00347"></a>00347                   }
<a name="l00348"></a>00348                   _avADCIsValid=<span class="keyword">true</span>;
<a name="l00349"></a>00349                 }
<a name="l00350"></a>00350               }
<a name="l00351"></a>00351               <span class="keywordflow">else</span> {
<a name="l00352"></a>00352                 <span class="keywordflow">do</span> {
<a name="l00353"></a>00353 <span class="preprocessor">#ifdef BOUNDARY_CHECK</span>
<a name="l00354"></a>00354 <span class="preprocessor"></span>                  assert(       adc_access.getModuleIndex()&lt; _avValues[kNoiseHistory].size());
<a name="l00355"></a>00355 <span class="preprocessor">#endif           </span>
<a name="l00356"></a>00356 <span class="preprocessor"></span>                  UInt_t module_index_offset=UINT_MAX;
<a name="l00357"></a>00357                   <span class="keywordflow">if</span> (module_index_array.size()&gt;0) {
<a name="l00358"></a>00358                     UInt_t module_index=adc_access.getModuleIndex();
<a name="l00359"></a>00359                     <span class="comment">//            UInt_t cell_index=adc_access.getCellIndexOnModule();</span>
<a name="l00360"></a>00360                     <span class="keywordflow">if</span> ((module_index_array.size()) &gt;static_cast&lt;UInt_t&gt;(module_index) + 1) {
<a name="l00361"></a>00361                       module_index_offset=<span class="keyword">static_cast&lt;</span>UInt_t<span class="keyword">&gt;</span>(module_index_array[module_index]);
<a name="l00362"></a>00362                     }
<a name="l00363"></a>00363                   }
<a name="l00364"></a>00364 
<a name="l00365"></a>00365                   <span class="keywordflow">do</span> {
<a name="l00366"></a>00366                     UInt_t chip_i=adc_access.getCellIndexOnModule()%__nChips;
<a name="l00367"></a>00367 <span class="preprocessor">#ifdef BOUNDARY_CHECK</span>
<a name="l00368"></a>00368 <span class="preprocessor"></span>                    assert(chip_i &lt; _avValues[kNoiseHistory][adc_access.getModuleIndex()].size());
<a name="l00369"></a>00369 <span class="preprocessor">#endif              </span>
<a name="l00370"></a>00370 <span class="preprocessor"></span>                    Int_t raw_adc_value=adc_access.getAdcValue();
<a name="l00371"></a>00371 
<a name="l00372"></a>00372                     Float_t noise=FLT_MAX;
<a name="l00373"></a>00373                     Float_t pedestal=0;
<a name="l00374"></a>00374                     <span class="keywordflow">if</span> (module_index_offset&lt;UINT_MAX) {
<a name="l00375"></a>00375                       <a class="code" href="classCALICE_1_1CellParameter.html" title="Information about a pad: Pedestal, noise, etc.">CellParameter</a> cell_parameter(cell_parameters-&gt;getElementAt(module_index_offset+adc_access.getCellIndexOnModule()));
<a name="l00376"></a>00376                       noise=cell_parameter.<a class="code" href="classCALICE_1_1CellParameter.html#a58d1f99e4ef0452b94fef27d5de1cc1e" title="Get the noise.">getNoise</a>();
<a name="l00377"></a>00377                       pedestal=cell_parameter.<a class="code" href="classCALICE_1_1CellParameter.html#a3223608e5f680b674e7181b5c4495935" title="Get the pedestal.">getPedestal</a>();
<a name="l00378"></a>00378                       _avValues[kNoiseHistory][adc_access.getModuleIndex()][chip_i].add(noise);
<a name="l00379"></a>00379                       _avValues[kPedestalHistory][adc_access.getModuleIndex()][chip_i].add(pedestal);
<a name="l00380"></a>00380                     }
<a name="l00381"></a>00381                     <span class="keywordflow">if</span> (raw_adc_value-pedestal&lt;_signalCut*noise) {
<a name="l00382"></a>00382                       _avValues[kADCHistory][adc_access.getModuleIndex()][chip_i].add(raw_adc_value-_avADC[adc_access.getModuleIndex()][adc_access.getCellIndexOnModule()].mean());
<a name="l00383"></a>00383                     }
<a name="l00384"></a>00384                     <span class="keywordflow">else</span> {
<a name="l00385"></a>00385                       _avValues[kHitHistory][adc_access.getModuleIndex()][chip_i].add(1);
<a name="l00386"></a>00386                     }
<a name="l00387"></a>00387                   } <span class="keywordflow">while</span> (adc_access.nextValue());
<a name="l00388"></a>00388                 } <span class="keywordflow">while</span> (adc_access.nextBlock());
<a name="l00389"></a>00389               }
<a name="l00390"></a>00390             }
<a name="l00391"></a>00391         }
<a name="l00392"></a>00392         
<a name="l00393"></a>00393         <span class="keywordflow">if</span> (event_nr%static_cast&lt;UInt_t&gt;(_eventPar[0])==0) {
<a name="l00394"></a>00394           <span class="keywordflow">if</span> (_avADCIsValid) {
<a name="l00395"></a>00395             <span class="keywordflow">for</span> (UInt_t history_i=0; history_i&lt;kNHistoryGraphs; history_i++) {
<a name="l00396"></a>00396 <span class="preprocessor">#ifdef BOUNDARY_CHECK</span>
<a name="l00397"></a>00397 <span class="preprocessor"></span>              assert( history_i&lt;_avValueHistoryKey.size() );
<a name="l00398"></a>00398 <span class="preprocessor">#endif</span>
<a name="l00399"></a>00399 <span class="preprocessor"></span>              <a class="code" href="classhistmgr_1_1GraphCollection__t.html" title="Light wrapper around a LCCollection to facilitate the handling of collections of...">histmgr::GraphCollection_t</a> &amp;graph_col=histogramList-&gt;<a class="code" href="classhistmgr_1_1HistMgr.html#a6c5ea89b82f7d9df93423976abdf6470" title="Get a graph collection.">getGraphCollection</a>(_graphGroupKey,_avValueHistoryKey[history_i]);
<a name="l00400"></a>00400               UInt_t history_val_i = graph_col.appendXValue(stamp);
<a name="l00401"></a>00401 
<a name="l00402"></a>00402               <span class="keywordflow">for</span> (UInt_t module_i=0; module_i&lt;_mapping.getNModules(); module_i++) {
<a name="l00403"></a>00403                 <span class="keywordflow">for</span> (UInt_t chip_i=0; chip_i&lt;_mapping.getNCellsPerModule(module_i)/__nSamplesPerChip; chip_i++) {
<a name="l00404"></a>00404                   <span class="keywordflow">if</span> (_avValues[history_i][module_i][chip_i].weight()&gt;=0) {
<a name="l00405"></a>00405                     _avValues[history_i][module_i][chip_i].calculate();
<a name="l00406"></a>00406 
<a name="l00407"></a>00407                     graph_col.setYValue(module_i,chip_i,kGraphMean,history_val_i, _avValues[history_i][module_i][chip_i].mean());
<a name="l00408"></a>00408                     graph_col.setYValue(module_i,chip_i,kGraphRMS,history_val_i, _avValues[history_i][module_i][chip_i].sigma());
<a name="l00409"></a>00409                     graph_col.setYValue(module_i,chip_i,kGraphMin,history_val_i, _avValues[history_i][module_i][chip_i].min());
<a name="l00410"></a>00410                     graph_col.setYValue(module_i,chip_i,kGraphMax,history_val_i, _avValues[history_i][module_i][chip_i].max());
<a name="l00411"></a>00411                     graph_col.setYValue(module_i,chip_i,kGraphWeight,history_val_i, _avValues[history_i][module_i][chip_i].weight());
<a name="l00412"></a>00412 
<a name="l00413"></a>00413 <span class="comment">//                  _history[history_i][kGraphMean][module_i][chip_i].push_back(_avValues[history_i][module_i][chip_i].mean());</span>
<a name="l00414"></a>00414 <span class="comment">//                  _history[history_i][kGraphRMS][module_i][chip_i].push_back(_avValues[history_i][module_i][chip_i].sigma());</span>
<a name="l00415"></a>00415 <span class="comment">//                  _history[history_i][kGraphMin][module_i][chip_i].push_back(_avValues[history_i][module_i][chip_i].min());</span>
<a name="l00416"></a>00416 <span class="comment">//                  _history[history_i][kGraphMax][module_i][chip_i].push_back(_avValues[history_i][module_i][chip_i].max());</span>
<a name="l00417"></a>00417 <span class="comment">//                  _history[history_i][kGraphWeight][module_i][chip_i].push_back(_avValues[history_i][module_i][chip_i].weight());</span>
<a name="l00418"></a>00418                   }
<a name="l00419"></a>00419                   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (history_val_i&gt;0) {
<a name="l00420"></a>00420                     graph_col.setYValue(module_i,chip_i,kGraphMean,history_val_i,graph_col.getYValue(module_i,chip_i,kGraphMean,history_val_i-1));
<a name="l00421"></a>00421                     graph_col.setYValue(module_i,chip_i,kGraphRMS,history_val_i,graph_col.getYValue(module_i,chip_i,kGraphRMS,history_val_i-1));
<a name="l00422"></a>00422                     graph_col.setYValue(module_i,chip_i,kGraphMin,history_val_i,graph_col.getYValue(module_i,chip_i,kGraphMin,history_val_i-1));
<a name="l00423"></a>00423                     graph_col.setYValue(module_i,chip_i,kGraphMax,history_val_i,graph_col.getYValue(module_i,chip_i,kGraphMax,history_val_i-1));
<a name="l00424"></a>00424                     graph_col.setYValue(module_i,chip_i,kGraphWeight,history_val_i,graph_col.getYValue(module_i,chip_i,kGraphWeight,history_val_i-1));
<a name="l00425"></a>00425 <span class="comment">//                  _history[history_i][kGraphMean][module_i][chip_i].push_back(_history[history_i][kGraphMean][module_i][chip_i].back());</span>
<a name="l00426"></a>00426 <span class="comment">//                  _history[history_i][kGraphRMS][module_i][chip_i].push_back(_history[history_i][kGraphRMS][module_i][chip_i].back());</span>
<a name="l00427"></a>00427 <span class="comment">//                  _history[history_i][kGraphMin][module_i][chip_i].push_back(_history[history_i][kGraphMin][module_i][chip_i].back());</span>
<a name="l00428"></a>00428 <span class="comment">//                  _history[history_i][kGraphMax][module_i][chip_i].push_back(_history[history_i][kGraphMax][module_i][chip_i].back());</span>
<a name="l00429"></a>00429 <span class="comment">//                  _history[history_i][kGraphWeight][module_i][chip_i].push_back(_history[history_i][kGraphWeight][module_i][chip_i].back());</span>
<a name="l00430"></a>00430                   }
<a name="l00431"></a>00431                   <span class="keywordflow">else</span> {
<a name="l00432"></a>00432                     graph_col.setYValue(module_i,chip_i,kGraphMean,history_val_i,0.);
<a name="l00433"></a>00433                     graph_col.setYValue(module_i,chip_i,kGraphRMS,history_val_i,0.);
<a name="l00434"></a>00434                     graph_col.setYValue(module_i,chip_i,kGraphMin,history_val_i,0.);
<a name="l00435"></a>00435                     graph_col.setYValue(module_i,chip_i,kGraphMax,history_val_i,0.);
<a name="l00436"></a>00436                     graph_col.setYValue(module_i,chip_i,kGraphWeight,history_val_i,0.);
<a name="l00437"></a>00437 <span class="comment">//                  _history[history_i][kGraphMean][module_i][chip_i].push_back(0.);</span>
<a name="l00438"></a>00438 <span class="comment">//                  _history[history_i][kGraphRMS][module_i][chip_i].push_back(0.);</span>
<a name="l00439"></a>00439 <span class="comment">//                  _history[history_i][kGraphMin][module_i][chip_i].push_back(0.);</span>
<a name="l00440"></a>00440 <span class="comment">//                  _history[history_i][kGraphMax][module_i][chip_i].push_back(0.);</span>
<a name="l00441"></a>00441 <span class="comment">//                  _history[history_i][kGraphWeight][module_i][chip_i].push_back(0.);</span>
<a name="l00442"></a>00442                   }
<a name="l00443"></a>00443                   _avValues[history_i][module_i][chip_i]=Average_t();
<a name="l00444"></a>00444                 }
<a name="l00445"></a>00445               }
<a name="l00446"></a>00446             }
<a name="l00447"></a>00447             <span class="comment">//      _historyStamps[kHistoryStamp].push_back(stamp);</span>
<a name="l00448"></a>00448           }
<a name="l00449"></a>00449         }
<a name="l00450"></a>00450       }
<a name="l00451"></a>00451       <span class="keywordflow">catch</span> (  DataNotAvailableException &amp;err) {
<a name="l00452"></a>00452       }
<a name="l00453"></a>00453     }
<a name="l00454"></a>00454     _confChanged=<span class="keyword">false</span>;
<a name="l00455"></a>00455   }
<a name="l00456"></a>00456 
<a name="l00457"></a>00457   <span class="keywordtype">void</span> AverageHistoryGraphs::end() 
<a name="l00458"></a>00458   {
<a name="l00459"></a>00459     <span class="comment">//    std::cout &lt;&lt; &quot;---- AverageHistoryGraphs: report&gt;&quot; &lt;&lt; std::endl;</span>
<a name="l00460"></a>00460     <span class="comment">//    std::cout &lt;&lt; &quot;\t&quot; &lt;&lt; _historyStamps[kHistoryStamp].size() &lt;&lt; &quot; : number of events per graph.&quot; &lt;&lt; std::endl;</span>
<a name="l00461"></a>00461     <span class="comment">//    writeGraphs();</span>
<a name="l00462"></a>00462   }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 <span class="comment">//   void AverageHistoryGraphs::writeGraphs() {</span>
<a name="l00465"></a>00465 <span class="comment">// #ifdef HAVE_ROOT</span>
<a name="l00466"></a>00466 <span class="comment">//     Bool_t have_events=false;</span>
<a name="l00467"></a>00467 <span class="comment">//     for (UInt_t hist_i=0; hist_i&lt;kNHistoryStamps; hist_i++) {</span>
<a name="l00468"></a>00468 <span class="comment">//       if (_historyStamps[hist_i].size()&gt;0 ) {</span>
<a name="l00469"></a>00469 <span class="comment">//      have_events=true;</span>
<a name="l00470"></a>00470 <span class="comment">//      break;</span>
<a name="l00471"></a>00471 <span class="comment">//       }</span>
<a name="l00472"></a>00472 <span class="comment">//     }</span>
<a name="l00473"></a>00473 <span class="comment">//     if (!have_events) return;</span>
<a name="l00474"></a>00474 
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 <span class="comment">//     TFile a_file(_outputFileName.c_str(),&quot;UPDATE&quot;);</span>
<a name="l00477"></a>00477     
<a name="l00478"></a>00478 <span class="comment">//     TDirectory *folder_dir=&amp;a_file;</span>
<a name="l00479"></a>00479 <span class="comment">//     if (!_folderName.empty()) {</span>
<a name="l00480"></a>00480 <span class="comment">//       TObject *obj=a_file.Get(_folderName.c_str());</span>
<a name="l00481"></a>00481 <span class="comment">//       if (obj &amp;&amp; obj-&gt;InheritsFrom(TDirectory::Class())) {</span>
<a name="l00482"></a>00482 <span class="comment">//      TDirectory *a_dir=(TDirectory *) obj;</span>
<a name="l00483"></a>00483 <span class="comment">//      a_dir-&gt;cd();</span>
<a name="l00484"></a>00484 <span class="comment">//      folder_dir=a_dir;</span>
<a name="l00485"></a>00485 <span class="comment">//       }</span>
<a name="l00486"></a>00486 <span class="comment">//       else {</span>
<a name="l00487"></a>00487 <span class="comment">//      a_file.mkdir(_folderName.c_str());</span>
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 <span class="comment">//      TObject *obj=a_file.Get(_folderName.c_str());</span>
<a name="l00490"></a>00490 <span class="comment">//      if (obj &amp;&amp; obj-&gt;InheritsFrom(TDirectory::Class())) {</span>
<a name="l00491"></a>00491 <span class="comment">//        TDirectory *a_dir=(TDirectory *) obj;</span>
<a name="l00492"></a>00492 <span class="comment">//        a_dir-&gt;cd();</span>
<a name="l00493"></a>00493 <span class="comment">//        folder_dir=a_dir;</span>
<a name="l00494"></a>00494 <span class="comment">//      }</span>
<a name="l00495"></a>00495 <span class="comment">//       }</span>
<a name="l00496"></a>00496 <span class="comment">//     }</span>
<a name="l00497"></a>00497     
<a name="l00498"></a>00498 <span class="comment">//     UInt_t n_written_graphs=0;</span>
<a name="l00499"></a>00499 <span class="comment">//     {</span>
<a name="l00500"></a>00500 <span class="comment">//       if (_historyStamps[kHistoryConfStamp].size()&gt;0) {</span>
<a name="l00501"></a>00501 <span class="comment">//      vector&lt;unsigned int&gt; yarr;</span>
<a name="l00502"></a>00502 <span class="comment">//      for (vector&lt;Double_t&gt;::const_iterator point_iter=_historyStamps[kHistoryConfStamp].begin();</span>
<a name="l00503"></a>00503 <span class="comment">//           point_iter!=_historyStamps[kHistoryConfStamp].end();</span>
<a name="l00504"></a>00504 <span class="comment">//           point_iter++) {</span>
<a name="l00505"></a>00505 <span class="comment">//        yarr.push_back(0);</span>
<a name="l00506"></a>00506 <span class="comment">//      }</span>
<a name="l00507"></a>00507 <span class="comment">//      TGraph *a_graph=makeGraph(&quot;configChanges&quot;,_historyStamps[kHistoryConfStamp],yarr);</span>
<a name="l00508"></a>00508 <span class="comment">//      if (a_graph) {</span>
<a name="l00509"></a>00509 <span class="comment">//        a_graph-&gt;Write();</span>
<a name="l00510"></a>00510 <span class="comment">//        n_written_graphs++;</span>
<a name="l00511"></a>00511 <span class="comment">//      }</span>
<a name="l00512"></a>00512 <span class="comment">//       }</span>
<a name="l00513"></a>00513 <span class="comment">//       if (_historyStamps[kHistoryStateStamp].size()&gt;0) {</span>
<a name="l00514"></a>00514 <span class="comment">//      TGraph *a_graph=makeGraph(&quot;stateChanges&quot;,_historyStamps[kHistoryStateStamp],_historyStamps[kHistoryStateValue]);</span>
<a name="l00515"></a>00515 <span class="comment">//      if (a_graph) {</span>
<a name="l00516"></a>00516 <span class="comment">//        a_graph-&gt;Write();</span>
<a name="l00517"></a>00517 <span class="comment">//        n_written_graphs++;</span>
<a name="l00518"></a>00518 <span class="comment">//      }</span>
<a name="l00519"></a>00519 <span class="comment">//       }</span>
<a name="l00520"></a>00520 <span class="comment">//     }</span>
<a name="l00521"></a>00521 <span class="comment">//     if (_historyStamps[kHistoryStamp].size()&gt;0) {</span>
<a name="l00522"></a>00522 <span class="comment">//       for (UInt_t history_i=0; history_i&lt;kNHistoryGraphs; history_i++) {</span>
<a name="l00523"></a>00523         
<a name="l00524"></a>00524 <span class="comment">//      if (folder_dir) {</span>
<a name="l00525"></a>00525 <span class="comment">//        folder_dir-&gt;cd();</span>
<a name="l00526"></a>00526 <span class="comment">//        TObject *obj=folder_dir-&gt;Get(__historyGraphNames[history_i]);</span>
<a name="l00527"></a>00527 <span class="comment">//        if (obj &amp;&amp; obj-&gt;InheritsFrom(TDirectory::Class())) {</span>
<a name="l00528"></a>00528 <span class="comment">//          TDirectory *a_dir=(TDirectory *) obj;</span>
<a name="l00529"></a>00529 <span class="comment">//          a_dir-&gt;cd();</span>
<a name="l00530"></a>00530 <span class="comment">//        }</span>
<a name="l00531"></a>00531 <span class="comment">//        else {</span>
<a name="l00532"></a>00532 <span class="comment">//          folder_dir-&gt;mkdir(__historyGraphNames[history_i]);</span>
<a name="l00533"></a>00533             
<a name="l00534"></a>00534 <span class="comment">//          TObject *obj=folder_dir-&gt;Get(__historyGraphNames[history_i]);</span>
<a name="l00535"></a>00535 <span class="comment">//          if (obj &amp;&amp; obj-&gt;InheritsFrom(TDirectory::Class())) {</span>
<a name="l00536"></a>00536 <span class="comment">//            TDirectory *a_dir=(TDirectory *) obj;</span>
<a name="l00537"></a>00537 <span class="comment">//            a_dir-&gt;cd();</span>
<a name="l00538"></a>00538 <span class="comment">//          }</span>
<a name="l00539"></a>00539 <span class="comment">//        }</span>
<a name="l00540"></a>00540 <span class="comment">//      }</span>
<a name="l00541"></a>00541 
<a name="l00542"></a>00542 <span class="comment">//      for (UInt_t graph_i=0; graph_i&lt;kNGraphs; graph_i++) {</span>
<a name="l00543"></a>00543 <span class="comment">//        if (graph_i==kGraphRMS) continue;</span>
<a name="l00544"></a>00544 <span class="comment">//        UInt_t module_i=0;</span>
<a name="l00545"></a>00545 <span class="comment">//        for (std::vector&lt; std::vector&lt; std::vector&lt; Float_t&gt; &gt; &gt;::const_iterator arr_iter=_history[history_i][graph_i].begin();</span>
<a name="l00546"></a>00546 <span class="comment">//             arr_iter!=_history[history_i][graph_i].end();</span>
<a name="l00547"></a>00547 <span class="comment">//             arr_iter++,module_i++) {</span>
<a name="l00548"></a>00548 <span class="comment">//          UInt_t chip_i=0;</span>
<a name="l00549"></a>00549 <span class="comment">//          for (std::vector&lt; std::vector&lt; Float_t&gt; &gt;::const_iterator iter=arr_iter-&gt;begin();</span>
<a name="l00550"></a>00550 <span class="comment">//               iter!=arr_iter-&gt;end();</span>
<a name="l00551"></a>00551 <span class="comment">//               iter++,chip_i++) {</span>
<a name="l00552"></a>00552 <span class="comment">// #ifdef BOUNDARY_CHECK</span>
<a name="l00553"></a>00553 <span class="comment">//            assert(iter-&gt;size()==_historyStamps[kHistoryStamp].size() );</span>
<a name="l00554"></a>00554 <span class="comment">// #endif</span>
<a name="l00555"></a>00555 <span class="comment">//            TGraph *a_graph=0;</span>
<a name="l00556"></a>00556 <span class="comment">//            std::stringstream name;</span>
<a name="l00557"></a>00557 <span class="comment">//            name &lt;&lt; __historyGraphNames[history_i] &lt;&lt; &quot;_&quot; &lt;&lt; __graphNames[graph_i] &lt;&lt; module_i &lt;&lt; &quot;_&quot; &lt;&lt; chip_i;</span>
<a name="l00558"></a>00558 <span class="comment">//            if (graph_i==kGraphMean) {</span>
<a name="l00559"></a>00559 <span class="comment">//              a_graph=makeGraph(name.str().c_str(),_historyStamps[kHistoryStamp],(*iter),</span>
<a name="l00560"></a>00560 <span class="comment">//                                _history[history_i][kGraphRMS][module_i][chip_i]);</span>
<a name="l00561"></a>00561 <span class="comment">//            }</span>
<a name="l00562"></a>00562 <span class="comment">//            else {</span>
<a name="l00563"></a>00563 <span class="comment">//              a_graph=makeGraph(name.str().c_str(),_historyStamps[kHistoryStamp],(*iter));</span>
<a name="l00564"></a>00564 <span class="comment">//            }</span>
<a name="l00565"></a>00565 <span class="comment">//            if (a_graph) {</span>
<a name="l00566"></a>00566 <span class="comment">//              a_graph-&gt;Write();</span>
<a name="l00567"></a>00567 <span class="comment">//              n_written_graphs++;</span>
<a name="l00568"></a>00568 <span class="comment">//              delete a_graph;</span>
<a name="l00569"></a>00569 <span class="comment">//            }</span>
<a name="l00570"></a>00570 <span class="comment">//          }</span>
<a name="l00571"></a>00571 <span class="comment">//        }</span>
<a name="l00572"></a>00572 <span class="comment">//      }</span>
<a name="l00573"></a>00573 <span class="comment">//       }</span>
<a name="l00574"></a>00574 <span class="comment">//     }</span>
<a name="l00575"></a>00575 <span class="comment">//     {</span>
<a name="l00576"></a>00576 <span class="comment">//       for (UInt_t history_i=0; history_i&lt;kNHistoryGraphs; history_i++) {</span>
<a name="l00577"></a>00577 <span class="comment">//      _historyStamps[history_i].clear();</span>
<a name="l00578"></a>00578 <span class="comment">//       }</span>
<a name="l00579"></a>00579 <span class="comment">//       for (UInt_t history_i=0; history_i&lt;kNHistoryGraphs; history_i++) {</span>
<a name="l00580"></a>00580 <span class="comment">//      for (UInt_t graph_i=0; graph_i&lt;kNGraphs; graph_i++) {</span>
<a name="l00581"></a>00581 <span class="comment">//        for (std::vector&lt; std::vector&lt; std::vector&lt; Float_t&gt; &gt; &gt;::iterator arr_iter=_history[history_i][graph_i].begin();</span>
<a name="l00582"></a>00582 <span class="comment">//             arr_iter!=_history[history_i][graph_i].end();</span>
<a name="l00583"></a>00583 <span class="comment">//             arr_iter++) {</span>
<a name="l00584"></a>00584 <span class="comment">//          for (std::vector&lt; std::vector&lt; Float_t&gt; &gt;::iterator iter=arr_iter-&gt;begin();</span>
<a name="l00585"></a>00585 <span class="comment">//               iter!=arr_iter-&gt;end();</span>
<a name="l00586"></a>00586 <span class="comment">//               iter++) {</span>
<a name="l00587"></a>00587 <span class="comment">//            iter-&gt;clear();</span>
<a name="l00588"></a>00588 <span class="comment">//          }</span>
<a name="l00589"></a>00589 <span class="comment">//        }</span>
<a name="l00590"></a>00590 <span class="comment">//      }</span>
<a name="l00591"></a>00591 <span class="comment">//       }</span>
<a name="l00592"></a>00592 <span class="comment">//     }</span>
<a name="l00593"></a>00593 
<a name="l00594"></a>00594 <span class="comment">//     std::cout &lt;&lt; &quot;\t Write: &quot; &lt;&lt; n_written_graphs &lt;&lt; &quot; graphs to &quot; &lt;&lt; _outputFileName.c_str() &lt;&lt; std::endl;</span>
<a name="l00595"></a>00595     
<a name="l00596"></a>00596 <span class="comment">// #endif      </span>
<a name="l00597"></a>00597 <span class="comment">//   }</span>
<a name="l00598"></a>00598 
<a name="l00599"></a>00599 
<a name="l00600"></a>00600 }
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 1 Dec 2017 for RAW2CALOHIT by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
